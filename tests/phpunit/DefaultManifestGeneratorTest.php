<?php

declare(strict_types=1);

namespace Keboola\DbExtractor\Tests;

use Keboola\DbExtractor\Adapter\Metadata\MetadataProvider;
use Keboola\DbExtractor\Adapter\ValueObject\ExportResult;
use Keboola\DbExtractor\Adapter\ValueObject\QueryMetadata;
use Keboola\DbExtractor\Manifest\DefaultManifestGenerator;
use Keboola\DbExtractor\Manifest\ManifestGenerator;
use Keboola\DbExtractor\TableResultFormat\Metadata\Builder\ColumnBuilder;
use Keboola\DbExtractor\TableResultFormat\Metadata\Builder\TableBuilder;
use Keboola\DbExtractor\TableResultFormat\Metadata\Manifest\DefaultManifestSerializer;
use Keboola\DbExtractor\TableResultFormat\Metadata\ValueObject\ColumnCollection;
use Keboola\DbExtractorConfig\Configuration\ValueObject\ExportConfig;
use Keboola\DbExtractorConfig\Configuration\ValueObject\InputTable;
use PHPUnit\Framework\Assert;
use PHPUnit\Framework\MockObject\MockObject;
use PHPUnit\Framework\TestCase;

class DefaultManifestGeneratorTest extends TestCase
{
    public function testCsvWithoutHeaderTableQuery(): void
    {
        $exportConfig = $this->createExportConfig();
        $exportResult = $this->createExportResult();

        $exportConfig->method('hasQuery')->willReturn(false);
        $exportConfig->method('hasColumns')->willReturn(true);
        $exportConfig->method('getColumns')->willReturn(['pk1', 'pk2', 'name', 'age']);
        $exportConfig->method('getTable')->willReturn(new InputTable('OutputTable', 'Schema'));
        $exportResult->method('hasCsvHeader')->willReturn(false);

        $manifestGenerator = $this->createManifestGenerator();
        $manifestData = $manifestGenerator->generate($exportConfig, $exportResult, false);

        unset($manifestData['column_metadata']); // generated by DefaultManifestSerializer, tested in lib
        Assert::assertSame([
            'destination' => 'output-table',
            'incremental' => false,
            'table_metadata' => [
                'KBC.name' => 'OutputTable',
                'KBC.sanitizedName' => 'OutputTable',
                'KBC.schema' => 'Schema',
            ],
            'schema' => [
                [
                    'nullable' => true,
                    'primary_key' => true,
                    'metadata' => [
                        'KBC.sourceName' => 'pk1',
                        'KBC.sanitizedName' => 'pk1',
                        'KBC.uniqueKey' => false,
                    ],
                    'name' => 'pk1',
                    'data_type' => [
                        'base' => [
                            'type' => 'INTEGER',
                        ],
                    ],
                ],
                [
                    'nullable' => true,
                    'primary_key' => true,
                    'metadata' => [
                        'KBC.sourceName' => 'pk2',
                        'KBC.sanitizedName' => 'pk2',
                        'KBC.uniqueKey' => false,
                    ],
                    'name' => 'pk2',
                    'data_type' => [
                        'base' => [
                            'type' => 'INTEGER',
                        ],
                    ],
                ],
                [
                    'nullable' => true,
                    'primary_key' => false,
                    'metadata' => [
                        'KBC.sourceName' => 'name',
                        'KBC.sanitizedName' => 'name',
                        'KBC.uniqueKey' => false,
                    ],
                    'name' => 'name',
                    'data_type' => [
                        'base' => [
                            'type' => 'STRING',
                        ],
                    ],
                ],
                [
                    'nullable' => true,
                    'primary_key' => false,
                    'metadata' => [
                        'KBC.sourceName' => 'age',
                        'KBC.sanitizedName' => 'age',
                        'KBC.uniqueKey' => false,
                    ],
                    'name' => 'age',
                    'data_type' => [
                        'base' => [
                            'type' => 'INTEGER',
                        ],
                    ],
                ],
            ],
        ], $manifestData);
    }

    public function testCsvWithoutHeaderTableQueryLegacyFormat(): void
    {
        $exportConfig = $this->createExportConfig();
        $exportResult = $this->createExportResult();

        $exportConfig->method('hasQuery')->willReturn(false);
        $exportConfig->method('hasColumns')->willReturn(true);
        $exportConfig->method('getColumns')->willReturn(['pk1', 'pk2', 'name', 'age']);
        $exportConfig->method('getTable')->willReturn(new InputTable('OutputTable', 'Schema'));
        $exportResult->method('hasCsvHeader')->willReturn(false);

        $manifestGenerator = $this->createManifestGenerator();
        $manifestData = $manifestGenerator->generate($exportConfig, $exportResult, true);

        unset($manifestData['column_metadata']); // generated by DefaultManifestSerializer, tested in lib
        Assert::assertSame([
            'destination' => 'output-table',
            'incremental' => false,
            'metadata' => [
                [
                    'key' => 'KBC.name',
                    'value' => 'OutputTable',
                ],
                [
                    'key' => 'KBC.sanitizedName',
                    'value' => 'OutputTable',
                ],
                [
                    'key' => 'KBC.schema',
                    'value' => 'Schema',
                ],
            ],
            'columns' => ['pk1', 'pk2', 'name', 'age'],
            'primary_key' => ['pk1', 'pk2'],
        ], $manifestData);
    }

    public function testCsvWithoutHeaderCustomQuery(): void
    {
        $exportConfig = $this->createExportConfig();
        $exportResult = $this->createExportResult();
        $queryMetadata = $this
            ->getMockBuilder(QueryMetadata::class)
            ->disableAutoReturnValueGeneration()
            ->getMock();

        $columnsRaw = ['pk1' => 'integer', 'pk2' => 'integer', 'generated_col' => 'string'];
        $columnsMetadata = [];
        foreach ($columnsRaw as $name => $type) {
            $builder = ColumnBuilder::create();
            $builder->setName($name);
            $builder->setType($type);
            $columnsMetadata[] = $builder->build();
        }

        $exportConfig->method('hasQuery')->willReturn(true);
        $exportConfig->method('getTable')->willReturn(new InputTable('OutputTable', 'Schema'));
        $exportResult->method('hasCsvHeader')->willReturn(false);
        $exportResult->method('getQueryMetadata')->willReturn($queryMetadata);
        $queryMetadata->method('getColumns')->willReturn(new ColumnCollection($columnsMetadata));

        $manifestGenerator = $this->createManifestGenerator();
        $manifestData = $manifestGenerator->generate($exportConfig, $exportResult, false);
        Assert::assertSame([
            'destination' => 'output-table',
            'incremental' => false,
            'schema' => [
                [
                    'nullable' => true,
                    'primary_key' => true,
                    'metadata' => [
                        'KBC.sourceName' => 'pk1',
                        'KBC.sanitizedName' => 'pk1',
                        'KBC.uniqueKey' => false,
                    ],
                    'name' => 'pk1',
                    'data_type' => [
                        'base' => [
                            'type' => 'INTEGER',
                        ],
                        'snowflake' => [
                            'type' => 'integer',
                        ],
                    ],
                ],
                [
                    'nullable' => true,
                    'primary_key' => true,
                    'metadata' => [
                        'KBC.sourceName' => 'pk2',
                        'KBC.sanitizedName' => 'pk2',
                        'KBC.uniqueKey' => false,
                    ],
                    'name' => 'pk2',
                    'data_type' => [
                        'base' => [
                            'type' => 'INTEGER',
                        ],
                        'snowflake' => [
                            'type' => 'integer',
                        ],
                    ],
                ],
                [
                    'nullable' => true,
                    'primary_key' => false,
                    'metadata' => [
                        'KBC.sourceName' => 'generated_col',
                        'KBC.sanitizedName' => 'generated_col',
                        'KBC.uniqueKey' => false,
                    ],
                    'name' => 'generated_col',
                    'data_type' => [
                        'base' => [
                            'type' => 'STRING',
                        ],
                        'snowflake' => [
                            'type' => 'string',
                        ],
                    ],
                ],
            ],
        ], $manifestData);
    }

    public function testCsvWithoutHeaderCustomQueryWithoutPrimaryKeys(): void
    {
        $exportConfig = $this->createExportConfig(false);
        $exportResult = $this->createExportResult();
        $queryMetadata = $this
            ->getMockBuilder(QueryMetadata::class)
            ->disableAutoReturnValueGeneration()
            ->getMock();

        $columnsRaw = ['pk1' => 'integer', 'pk2' => 'integer', 'generated_col' => 'string'];
        $columnsMetadata = [];
        foreach ($columnsRaw as $name => $type) {
            $builder = ColumnBuilder::create();
            $builder->setName($name);
            $builder->setType($type);
            $builder->setLength($type === 'integer' ? null : '255');
            $columnsMetadata[] = $builder->build();
        }

        $exportConfig->method('hasQuery')->willReturn(true);
        $exportConfig->method('getTable')->willReturn(new InputTable('OutputTable', 'Schema'));
        $exportResult->method('hasCsvHeader')->willReturn(false);
        $exportResult->method('getQueryMetadata')->willReturn($queryMetadata);
        $queryMetadata->method('getColumns')->willReturn(new ColumnCollection($columnsMetadata));

        $manifestGenerator = $this->createManifestGenerator();
        $manifestData = $manifestGenerator->generate($exportConfig, $exportResult, false);
        Assert::assertSame([
            'destination' => 'output-table',
            'incremental' => false,
            'schema' => [
                [
                    'nullable' => true,
                    'primary_key' => false,
                    'metadata' => [
                        'KBC.sourceName' => 'pk1',
                        'KBC.sanitizedName' => 'pk1',
                        'KBC.uniqueKey' => false,
                    ],
                    'name' => 'pk1',
                    'data_type' => [
                        'base' => [
                            'type' => 'INTEGER',
                        ],
                        'snowflake' => [
                            'type' => 'integer',
                        ],
                    ],
                ],
                [
                    'nullable' => true,
                    'primary_key' => false,
                    'metadata' => [
                        'KBC.sourceName' => 'pk2',
                        'KBC.sanitizedName' => 'pk2',
                        'KBC.uniqueKey' => false,
                    ],
                    'name' => 'pk2',
                    'data_type' => [
                        'base' => [
                            'type' => 'INTEGER',
                        ],
                        'snowflake' => [
                            'type' => 'integer',
                        ],
                    ],
                ],
                [
                    'nullable' => true,
                    'primary_key' => false,
                    'metadata' => [
                        'KBC.sourceName' => 'generated_col',
                        'KBC.sanitizedName' => 'generated_col',
                        'KBC.uniqueKey' => false,
                    ],
                    'name' => 'generated_col',
                    'data_type' => [
                        'base' => [
                            'type' => 'STRING',
                        ],
                        'snowflake' => [
                            'length' => '255',
                            'type' => 'string',
                        ],
                    ],
                ],
            ],
        ], $manifestData);
    }

    public function testCsvWithoutHeaderCustomQueryWithBaseTypeFallback(): void
    {
        $exportConfig = $this->createExportConfig(false);
        $exportResult = $this->createExportResult();
        $queryMetadata = $this
            ->getMockBuilder(QueryMetadata::class)
            ->disableAutoReturnValueGeneration()
            ->getMock();

        // longtext is not supported type in Snowflake, should fall back to "string"
        $columnsRaw = ['pk1' => 'integer', 'pk2' => 'integer', 'generated_col' => 'longtext'];

        $columnsMetadata = [];
        foreach ($columnsRaw as $name => $type) {
            $builder = ColumnBuilder::create();
            $builder->setName($name);
            $builder->setType($type);
            $columnsMetadata[] = $builder->build();
        }

        $exportConfig->method('hasQuery')->willReturn(true);
        $exportConfig->method('getTable')->willReturn(new InputTable('OutputTable', 'Schema'));
        $exportResult->method('hasCsvHeader')->willReturn(false);
        $exportResult->method('getQueryMetadata')->willReturn($queryMetadata);
        $queryMetadata->method('getColumns')->willReturn(new ColumnCollection($columnsMetadata));

        $manifestGenerator = $this->createManifestGenerator();
        $manifestData = $manifestGenerator->generate($exportConfig, $exportResult, false);

        Assert::assertEquals('string', $manifestData['schema'][2]['data_type']['base']['type']);
        Assert::assertEquals('longtext', $manifestData['schema'][2]['data_type']['snowflake']['type']);
    }

    public function testCsvWithoutHeaderCustomQueryLegacyFormat(): void
    {
        $exportConfig = $this->createExportConfig();
        $exportResult = $this->createExportResult();
        $queryMetadata = $this
            ->getMockBuilder(QueryMetadata::class)
            ->disableAutoReturnValueGeneration()
            ->getMock();

        $columnsRaw = ['pk1' => 'integer', 'pk2' => 'integer', 'generated_col' => 'string'];
        $columnsMetadata = [];
        foreach ($columnsRaw as $name => $type) {
            $builder = ColumnBuilder::create();
            $builder->setName($name);
            $builder->setType($type);
            $columnsMetadata[] = $builder->build();
        }

        $exportConfig->method('hasQuery')->willReturn(true);
        $exportConfig->method('getTable')->willReturn(new InputTable('OutputTable', 'Schema'));
        $exportResult->method('hasCsvHeader')->willReturn(false);
        $exportResult->method('getQueryMetadata')->willReturn($queryMetadata);
        $queryMetadata->method('getColumns')->willReturn(new ColumnCollection($columnsMetadata));

        $manifestGenerator = $this->createManifestGenerator();
        $manifestData = $manifestGenerator->generate($exportConfig, $exportResult, true);

        unset($manifestData['column_metadata']); // generated by DefaultManifestSerializer, tested in lib
        Assert::assertSame([
            'destination' => 'output-table',
            'incremental' => false,
            'columns' => ['pk1', 'pk2', 'generated_col'],
            'primary_key' => ['pk1', 'pk2'],
        ], $manifestData);
    }

    /**
     * @psalm-return MockObject&ExportConfig
     * @return MockObject|ExportConfig
     */
    protected function createExportConfig(bool $setPrimaryKeys = true): MockObject
    {
        $exportConfig = $this
            ->getMockBuilder(ExportConfig::class)
            ->disableOriginalConstructor()
            ->disableAutoReturnValueGeneration()
            ->getMock();

        $exportConfig->method('getOutputTable')->willReturn('output-table');
        $exportConfig->method('isIncrementalLoading')->willReturn(false);
        $exportConfig->method('hasPrimaryKey')->willReturn($setPrimaryKeys);
        if ($setPrimaryKeys) {
            $exportConfig->method('getPrimaryKey')->willReturn(['pk1', 'pk2']);
        }

        return $exportConfig;
    }

    /**
     * @psalm-return MockObject&ExportResult
     * @return MockObject|ExportResult
     */
    protected function createExportResult(): MockObject
    {
        return $this
            ->getMockBuilder(ExportResult::class)
            ->disableOriginalConstructor()
            ->disableAutoReturnValueGeneration()
            ->getMock();
    }

    protected function createManifestGenerator(): ManifestGenerator
    {
        $metadataProvider = $this
            ->getMockBuilder(MetadataProvider::class)
            ->disableAutoReturnValueGeneration()
            ->getMock();

        $tableBuilder = TableBuilder::create();
        $tableBuilder
            ->setName('OutputTable')
            ->setSchema('Schema');
        $tableBuilder
            ->addColumn()
            ->setName('pk1')
            ->setType('INTEGER');
        $tableBuilder
            ->addColumn()
            ->setName('pk2')
            ->setType('INTEGER');
        $tableBuilder
            ->addColumn()
            ->setName('date')
            ->setType('DATE');
        $tableBuilder
            ->addColumn()
            ->setName('name')
            ->setType('VARCHAR')
            ->setLength('255');
        $tableBuilder
            ->addColumn()
            ->setName('age')
            ->setType('INTEGER');

        $metadataProvider->method('getTable')->willReturn($tableBuilder->build());

        $manifestSerializer = new DefaultManifestSerializer();
        return new DefaultManifestGenerator($metadataProvider, $manifestSerializer, 'Snowflake');
    }
}
